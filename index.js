// S·ª¨ D·ª§NG SEVER ƒê∆†N THU·∫¶N, HO·∫†T ƒê·ªòNG V·ªöI FILE DATA.XLSX

// Function to load knowledge from an Excel file (This mean Keyword)
// // Befor running this code, you have to install package 'xlsx' and 'dotenv'.

// const fs = require('fs');
// const path = require('path');
// const XLSX = require('xlsx');
// let knowledge = [];

// const DATA_FILE = path.join(__dirname, 'data.xlsx');
// // Load (or reload) the sheet into memory
// function loadKnowledge() {

//   const wb = XLSX.readFile(DATA_FILE);  // Read the Excel file
//   console.log('üìÑ Sheets trong data.xlsx:', wb.SheetNames);
//   knowledge = XLSX.utils
//     .sheet_to_json(wb.Sheets['Sheet1'], { header: 1 })
//     .slice(1)               // drop header row
//     .map(([Keyword, Response]) => ({ Keyword, Response }));
// }
// loadKnowledge();



// console.log(knowledge);  // Log the knowledge base to the console


// // Import to save data in Excel file
// const CHATLOG_FILE = path.join(__dirname, 'chat_log.xlsx'); // dirname means the current directory

// // Fucntion to get AI reply from OpenRouter API
// require('dotenv').config();
// const express = require('express');
// const cors = require('cors');
// const axios = require('axios');

// const app = express();
// app.use(cors());
// app.use(express.json());


// // Create a function to log chat turns
// function logChatTurn({ userMessage, botReply, responseType }) {
//   const today = new Date().toISOString().split('T')[0];  // Get today's date in YYYY-MM-DD format
//   // 1. Load or create the workbook
//   const wb = fs.existsSync(CHATLOG_FILE)
//     ? XLSX.readFile(CHATLOG_FILE)  // If file exists, read it
//     : XLSX.utils.book_new();  // If not, create a new workbook

//     // 2. Load or init rows
//     let rows;
//     if (wb.SheetNames.includes(today)) {
//       rows = XLSX.utils.sheet_to_json(wb.Sheets[today], {header: 1});  // Load existing rows
//     } else {
//       rows = [['Time', 'User', 'Bot', 'Type']];  // Initialize rows with headers
//     }

//     // 3. append turn
//     rows.push([new Date().toISOString(), userMessage, botReply, responseType]);  // Add the new chat turn

//     // 4. Write to the sheet
//     const ws = XLSX.utils.aoa_to_sheet(rows);  // Convert rows to a worksheet
//     wb.Sheets[today] = ws;  // Assign the worksheet to the sheet name (today's date)
//     if (!wb.SheetNames.includes(today)) {
//       wb.SheetNames.push(today);  // Add the sheet name if it doesn't exist
//     }
//     XLSX.writeFile(wb, CHATLOG_FILE);  // Write the workbook to the file
// }
// // Chat API route
// app.post('/api/chat', async (req, res) => {
//   // const userMessage = req.body.message;
//   const userMessage = req.body.message.toLowerCase();  // Convert user message to lowercase
//   let botReply, responseType;

//   // 1. Try to find a keyword in the knowledge base (Type: Static memory)
//   const hen = knowledge.find(item => userMessage.includes(item.Keyword.toLowerCase()));

//   /*
//   The "Keyword" is the column name in the Excel file.
//   The "Response" is the column name in the Excel file.
//   You can change the name of these columns in the Excel file.  :v
//   */

//   if (hen) {
//     // If a keyword is found, respond with the corresponding response
//     botReply = hen.Response;  // Get the response from the knowledge base
//     responseType = 'static';  // Set response type to static
//     res.json({ reply: botReply }); 
//   } else { 

//     try {
//       // Call the OpenRouter API to get a response
//       const resp = await axios.post(
//         'https://openrouter.ai/api/v1/chat/completions',  // OpenRouter API endpoint
//         {
//           model: 'openai/gpt-3.5-turbo',  // AI model to use
//           messages: [{ role: 'user', content: userMessage }]  // User's message
//         },
//         {
//           headers: {
//             Authorization: `Bearer ${process.env.OPENROUTER_API_KEY}`,  // Use your OpenRouter API key
//             'Content-Type': 'application/json'  // Set content type as JSON
//           }
//         }
//       );

//       const reply = resp.data.choices?.[0]?.message?.content || '';  // Get AI's reply
//       responseType = 'ai_kin cha na';
//       botReply = reply;  // Set the bot's reply to the AI's response
//       res.json({ reply });  // Send the reply back to the frontend

//     } catch (err) {
//       console.error('Error with OpenRouter:', err.response?.data || err.message || err);
//       responseType = 'error';
//       botReply = '(AI error, please try again.)';  // Set a default error message
//       res.status(500).json({ reply: botReply });  // Handle any errors
//     }
//   }

//   logChatTurn({userMessage: req.body.message, botReply, responseType});  // Log the chat turn
// });

// // Start the server on port 3000
// app.listen(3000, () => console.log('‚úÖServer running on http://localhost:3000'));


// S·ª¨ D·ª§NG SEVER ƒê∆†N THU·∫¶N, HO·∫†T ƒê·ªòNG V·ªöI FILE PRODUCTS.XLSX - NHI·ªÄU TH√îNG TIN H∆†N
// require('dotenv').config();
// const express = require('express');
// const cors = require('cors');
// const fs = require('fs');
// const path = require('path');
// const XLSX = require('xlsx');
// const axios = require('axios');

// const app = express();
// app.use(express.json());
// app.use(cors());

// // ======= C·∫•u h√¨nh ƒë∆∞·ªùng d·∫´n =======
// const DATA_FILE = process.env.KB_FILE      || path.join(__dirname, 'products.xlsx');
// const LOG_FILE  = process.env.LOG_FILE     || path.join(__dirname, 'chat_log.xlsx');
// const OPENROUTER_API_KEY = process.env.OPENROUTER_API_KEY;
// let _lastMtime = 0;

// // ======= Cache d·ªØ li·ªáu t·ª´ products.xlsx =======
// let dfProducts = [], dfPromo = [], dfContact = [], dfFaq = [];
// function loadData() {
//   let stat;
//   try { stat = fs.statSync(DATA_FILE); }
//   catch { console.error(`‚ùå Kh√¥ng t√¨m th·∫•y file ${DATA_FILE}`); return; }

//   if (stat.mtimeMs !== _lastMtime) {
//     const wb = XLSX.readFile(DATA_FILE);
//     dfProducts = XLSX.utils.sheet_to_json(wb.Sheets['Sanpham']   || []);
//     dfPromo    = XLSX.utils.sheet_to_json(wb.Sheets['Khuyenmai'] || []);
//     dfContact  = XLSX.utils.sheet_to_json(wb.Sheets['Lienhe']     || []);
//     dfFaq      = XLSX.utils.sheet_to_json(wb.Sheets['Hoidap']     || []);
//     _lastMtime = stat.mtimeMs;
//     console.log(`üîÑ Reloaded data from ${DATA_FILE}`);
//   }
// }
// // Load data l·∫ßn ƒë·∫ßu
// loadData();

// // ======= H√†m ghi log v√†o chat_log.xlsx =======
// function logChat(userMsg, botReply) {
//   // T√™n sheet theo ng√†y hi·ªán t·∫°i, v√≠ d·ª• "2025-05-20"
//   const today     = new Date();
//   const sheetName = today.toISOString().slice(0,10);

//   // M·ªü workbook n·∫øu ƒë√£ c√≥, ho·∫∑c t·∫°o m·ªõi
//   let wb;
//   if (fs.existsSync(LOG_FILE)) {
//     wb = XLSX.readFile(LOG_FILE);
//   } else {
//     wb = XLSX.utils.book_new();
//   }

//   // L·∫•y d·ªØ li·ªáu c≈© c·ªßa sheet h√¥m nay n·∫øu c√≥, ho·∫∑c kh·ªüi t·∫°o header
//   let data;
//   if (wb.SheetNames.includes(sheetName)) {
//     data = XLSX.utils.sheet_to_json(wb.Sheets[sheetName], { header: 1 });
//   } else {
//     data = [['Timestamp', 'UserMessage', 'BotReply']];
//   }

//   // Th√™m d√≤ng m·ªõi
//   data.push([
//     new Date().toISOString(),
//     userMsg,
//     botReply
//   ]);

//   // Chuy·ªÉn m·∫£ng 2D th√†nh worksheet
//   const ws = XLSX.utils.aoa_to_sheet(data);

//   // G√°n l·∫°i ho·∫∑c append sheet
//   if (!wb.SheetNames.includes(sheetName)) {
//     XLSX.utils.book_append_sheet(wb, ws, sheetName);
//   } else {
//     wb.Sheets[sheetName] = ws;
//   }

//   // Ghi file
//   XLSX.writeFile(wb, LOG_FILE);
// }

// // ======= C√°c h√†m x·ª≠ l√Ω tƒ©nh (gi·ªØ nguy√™n) =======
// function topSelling() {
//   if (!dfProducts.length || dfProducts[0]['S·ªë l∆∞·ª£t b√°n'] == null) {
//     return 'D·ªØ li·ªáu l∆∞·ª£t b√°n ch∆∞a c√≥.';
//   }
//   const top3 = [...dfProducts]
//     .sort((a, b) => (b['S·ªë l∆∞·ª£t b√°n']||0) - (a['S·ªë l∆∞·ª£t b√°n']||0))
//     .slice(0, 3);
//   return 'Top s·∫£n ph·∫©m b√°n ch·∫°y:\n' +
//     top3.map(r => `- ${r['T√™n s·∫£n ph·∫©m']} (${r['S·ªë l∆∞·ª£t b√°n']} l∆∞·ª£t)`).join('\n');
// }

// function currentPromos() {
//   if (!dfPromo.length) return 'Hi·ªán ch∆∞a c√≥ ch∆∞∆°ng tr√¨nh khuy·∫øn m√£i n√†o.';
//   return 'C√°c ch∆∞∆°ng tr√¨nh khuy·∫øn m√£i:\n' + dfPromo.map(r =>
//     `üéÅ ${r['TenChuongTrinh']}: ${r['MoTa']} (√Åp d·ª•ng: ${r['SanPhamApDung']})`
//   ).join('\n');
// }

// function promoForProduct(msg) {
//   let out = dfPromo
//     .filter(r =>
//       String(r['SanPhamApDung']).toLowerCase()!=='t·∫•t c·∫£' &&
//       msg.includes(String(r['SanPhamApDung']).toLowerCase())
//     )
//     .map(r =>
//       `üéâ ${r['TenChuongTrinh']}: ${r['MoTa']} (√Åp d·ª•ng: ${r['SanPhamApDung']})`
//     );
//   if (!out.length) {
//     out = dfPromo
//       .filter(r => String(r['SanPhamApDung']).trim().toLowerCase()==='t·∫•t c·∫£')
//       .map(r =>
//         `üéâ ${r['TenChuongTrinh']}: ${r['MoTa']} (√Åp d·ª•ng: T·∫•t c·∫£)`
//       );
//   }
//   return out.length ? out.join('\n') : null;
// }

// function detailedProductInfo(msg) {
//   for (const r of dfProducts) {
//     const name = String(r['T√™n s·∫£n ph·∫©m']).toLowerCase();
//     if (msg.includes(name)) {
//       const res = [`S·∫£n ph·∫©m: ${r['T√™n s·∫£n ph·∫©m']}`];
//       if (msg.includes('gi√°'))      res.push(`Gi√°: ${r['Gi√°']} VND`);
//       if (msg.includes('m√†u'))      res.push(`M√†u: ${r['M√†u'] || 'Kh√¥ng r√µ'}`);
//       if (msg.includes('size')||
//           msg.includes('k√≠ch c·ª°')) res.push(`Size: ${r['Size'] || 'Kh√¥ng r√µ'}`);
//       if (msg.includes('s·ªë l∆∞·ª£ng')) res.push(`S·ªë l∆∞·ª£ng c√≤n: ${r['S·ªë l∆∞·ª£ng'] || 'Kh√¥ng r√µ'}`);
//       if (res.length === 1) {
//         res.push(
//           `Gi√°: ${r['Gi√°']} VND`,
//           `M√†u: ${r['M√†u'] || 'Kh√¥ng r√µ'}`,
//           `Size: ${r['Size'] || 'Kh√¥ng r√µ'}`,
//           `S·ªë l∆∞·ª£ng c√≤n: ${r['S·ªë l∆∞·ª£ng'] || 'Kh√¥ng r√µ'}`
//         );
//       }
//       return res.join('\n');
//     }
//   }
//   return null;
// }

// function faqResponse(msg) {
//   for (const r of dfFaq) {
//     if (msg.includes(String(r['CauHoiThuongGap']).toLowerCase())) {
//       return r['TraLoi'];
//     }
//   }
//   return null;
// }

// function contactInfo() {
//   if (!dfContact.length) return null;
//   return 'Th√¥ng tin li√™n h·ªá:\n' + dfContact
//     .map(r => `${r['ThongTin']}: ${r['NoiDung']}`)
//     .join('\n');
// }

// function handleUnclear(msg) {
//   return faqResponse(msg) || contactInfo() || 'Xin l·ªói, t√¥i ch∆∞a r√µ √Ω b·∫°n.';
// }

// // ======= Fallback AI =======
// async function aiGenerateReply(message) {
//   const url = 'https://openrouter.ai/api/v1/chat/completions';
//   const headers = {
//     'Authorization': `Bearer ${OPENROUTER_API_KEY}`,
//     'Content-Type': 'application/json'
//   };
//   const payload = {
//     model: 'openai/gpt-3.5-turbo',
//     messages: [
//       { role: 'system', content: 'B·∫°n l√† tr·ª£ l√Ω b√°n h√†ng th√¢n thi·ªán.' },
//       { role: 'user',   content: message }
//     ]
//   };
//   const resp = await axios.post(url, payload, { headers });
//   return resp.data.choices?.[0]?.message?.content
//     || 'Xin l·ªói, t√¥i kh√¥ng hi·ªÉu y√™u c·∫ßu.';
// }

// // ======= Route /api/chat =======
// app.post('/api/chat', async (req, res) => {
//   loadData();
//   const msg = (req.body.message||'').toLowerCase();

//   let reply;
//   if (msg.includes('b√°n ch·∫°y')) {
//     reply = topSelling();
//   }
//   else if (msg.includes('khuy·∫øn m√£i') || msg.includes('gi·∫£m gi√°')) {
//     reply = promoForProduct(msg) || currentPromos();
//   }
//   else if ((reply = detailedProductInfo(msg))) {
//     // v·ª´a g√°n v·ª´a ki·ªÉm
//   }
//   else if ((reply = faqResponse(msg))) {
//   }
//   else if (msg.includes('li√™n h·ªá') || msg.includes('h·ªó tr·ª£')) {
//     reply = contactInfo();
//   }
//   else {
//     try {
//       reply = await aiGenerateReply(msg);
//     } catch (e) {
//       console.error(e);
//       reply = 'Xin l·ªói, ƒë√£ x·∫£y ra l·ªói khi k·∫øt n·ªëi AI.';
//     }
//   }

//   // Ghi log tr∆∞·ªõc khi tr·∫£ v·ªÅ
//   logChat(msg, reply);
//   return res.json({ reply });
// });

// // ======= Kh·ªüi ƒë·ªông server =======
// const PORT = process.env.PORT || 3000;
// app.listen(PORT, () => {
//   console.log(`üöÄ Server ƒëang ch·∫°y tr√™n http://localhost:${PORT}`);
// });


// // ======= ƒêo·∫°n m√£ n√†y d√πng ƒë·ªÉ ki·ªÉm tra xem server c√≥ ch·∫°y kh√¥ng =======
// ƒê·ªçc bi·∫øn m√¥i tr∆∞·ªùng t·ª´ file .env
require('dotenv').config();
const express = require('express');
const cors    = require('cors');
const fs      = require('fs');
const path    = require('path');
const XLSX    = require('xlsx');
const axios   = require('axios');

const app = express();
app.use(express.json());
app.use(cors());

// ======= C·∫•u h√¨nh ƒë∆∞·ªùng d·∫´n & key =======
const DATA_FILE           = process.env.KB_FILE  || path.join(__dirname, 'products.xlsx');
const LOG_FILE            = process.env.LOG_FILE || path.join(__dirname, 'chat_log.xlsx');
const OPENROUTER_API_KEY  = process.env.OPENROUTER_API_KEY;
let _lastMtime            = 0; //L∆∞u th·ªùi gian s·ª≠a ƒë·ªïi cu·ªëi c√πng c·ªßa file Excel

// ======= Cache d·ªØ li·ªáu Excel =======
let dfProducts = [], dfPromo = [], dfContact = [], dfFaq = [];
function loadData() {
  let stat;
  try { stat = fs.statSync(DATA_FILE); }
  catch { console.error(`‚ùå Kh√¥ng t√¨m th·∫•y file ${DATA_FILE}`); return; }

  if (stat.mtimeMs !== _lastMtime) {
    const wb = XLSX.readFile(DATA_FILE);
    dfProducts = XLSX.utils.sheet_to_json(wb.Sheets['Sanpham']   || []); // ƒê·ªçc sheet "Sanpham"
    dfPromo    = XLSX.utils.sheet_to_json(wb.Sheets['Khuyenmai'] || []);
    dfContact  = XLSX.utils.sheet_to_json(wb.Sheets['Lienhe']     || []);
    dfFaq      = XLSX.utils.sheet_to_json(wb.Sheets['Hoidap']     || []);
    _lastMtime = stat.mtimeMs;
    console.log(`üîÑ Reloaded data from ${DATA_FILE}`);
  }
}

// M·ªói l·∫ßn load s·∫Ω ki·ªÉm tra th·ªùi gian thay ƒë·ªïi c·ªßa file, n·∫øu kh√°c th√¨ s·∫Ω ƒë·ªçc l·∫°i to√†n b·ªô d·ªØ li·ªáu
loadData();

// ======= Load l·ªãch s·ª≠ chat h√¥m nay ƒë·ªÉ cho AI h·ªçc =======
// ƒê·ªçc l·∫°i l·ªãch s·ª≠ chat t·ª´ file chat_log.xlsx
function loadChatHistory() {
  if (!fs.existsSync(LOG_FILE)) return '';
  const wb    = XLSX.readFile(LOG_FILE);
  const today = new Date().toISOString().slice(0,10);
  if (!wb.SheetNames.includes(today)) return '';

  // ƒê·ªçc t·∫•t c·∫£ d√≤ng (tr·ª´ header) trong sheet h√¥m nay
  const rows = XLSX.utils.sheet_to_json(wb.Sheets[today], { header: 1 }); // M·ªói ng√†y s·∫Ω c√≥ 1 sheet
  const data = rows.slice(1);  // b·ªè header, gi·ªØ to√†n b·ªô l·ªãch s·ª≠

  // Gh√©p th√†nh chu·ªói User/Bot (L·∫•y to√†n b·ªô th√¥ng tin c·ªßa sheet h√¥m nay r√≤i gh√©p th√†nh d·∫°ng chu·ªói) D·∫°y AI ng·ªØ c·∫£nh tr∆∞·ªõc ƒë√≥
  return data
    .map(r => `User: ${r[1]}\nBot: ${r[2]}`)
    .join('\n\n');
}


// ======= Ghi log m·ªói l·∫ßn tr√≤ chuy·ªán =======
function logChat(userMsg, botReply) {
  const today     = new Date().toISOString().slice(0,10);
  let wb;
  if (fs.existsSync(LOG_FILE)) {
    wb = XLSX.readFile(LOG_FILE);
  } else {
    wb = XLSX.utils.book_new();
  }

  // L·∫•y/c√†i header cho sheet h√¥m nay
  let data;
  if (wb.SheetNames.includes(today)) {
    data = XLSX.utils.sheet_to_json(wb.Sheets[today], { header: 1 });
  } else {
    data = [['Timestamp','UserMessage','BotReply']];
  }

  data.push([ new Date().toISOString(), userMsg, botReply ]);
  const ws = XLSX.utils.aoa_to_sheet(data);

  if (!wb.SheetNames.includes(today)) {
    XLSX.utils.book_append_sheet(wb, ws, today);
  } else {
    wb.Sheets[today] = ws;
  }
  XLSX.writeFile(wb, LOG_FILE);
}

// ======= C√°c h√†m x·ª≠ l√Ω tƒ©nh =======
function topSelling() { /* unchanged */ }
function currentPromos() { /* unchanged */ }
function promoForProduct(msg) { /* unchanged */ }
function detailedProductInfo(msg) { /* unchanged */ }
function faqResponse(msg) { /* unchanged */ }
function contactInfo() { /* unchanged */ }
function handleUnclear(msg) { /* unchanged */ }

// ======= Fallback AI v·ªõi l·ªãch s·ª≠ chat =======
async function aiGenerateReply(message) {
  const url = 'https://openrouter.ai/api/v1/chat/completions';
  const headers = {
    'Authorization': `Bearer ${OPENROUTER_API_KEY}`,
    'Content-Type': 'application/json'
  };

  // 1) t·∫£i l·ªãch s·ª≠ 5 turn cu·ªëi
  const history = loadChatHistory();

  // 2) build h·ªá th·ªëng prompt, g·ªìm: gi·ªõi thi·ªáu, d·ªØ li·ªáu s·∫£n ph·∫©m, l·ªãch s·ª≠ chat
  const systemParts = [
    'B·∫°n l√† tr·ª£ l√Ω b√°n h√†ng th√¢n thi·ªán.',
    'D∆∞·ªõi ƒë√¢y l√† d·ªØ li·ªáu s·∫£n ph·∫©m ƒë·ªÉ tham kh·∫£o:',
    // ng·∫Øn g·ªçn schema s·∫£n ph·∫©m, v√≠ d·ª• t√™n + gi√° (c√≥ th·ªÉ t√πy ch·ªânh n·∫øu c·∫ßn)
    dfProducts.slice(0,5).map(r =>
      `- ${r['T√™n s·∫£n ph·∫©m']}: Gi√° ${r['Gi√°']} VND, Size ${r['Size'] || 'n/a'}, T·ªìn ${r['S·ªë l∆∞·ª£ng'] || 'n/a'}`
    ).join('\n'),
  ];
  if (history) {
    systemParts.push('L·ªãch s·ª≠ tr√≤ chuy·ªán g·∫ßn ƒë√¢y:\n' + history);
  }

  const messages = [
    { role: 'system', content: systemParts.join('\n\n') },
    { role: 'user',   content: message }
  ];

  const payload = { model: 'openai/gpt-3.5-turbo', messages };
  const resp    = await axios.post(url, payload, { headers });
  return resp.data.choices?.[0]?.message?.content || 'Xin l·ªói, t√¥i kh√¥ng hi·ªÉu y√™u c·∫ßu.';
}

// ======= Route /api/chat =======
app.post('/api/chat', async (req, res) => {
  loadData();
  const msg = (req.body.message||'').toLowerCase();

  let reply;
  if (msg.includes('b√°n ch·∫°y')) {
    reply = topSelling();
  }
  else if (msg.includes('khuy·∫øn m√£i') || msg.includes('gi·∫£m gi√°')) {
    reply = promoForProduct(msg) || currentPromos();
  }
  else if ((reply = detailedProductInfo(msg))) {
    /* static detail */
  }
  else if ((reply = faqResponse(msg))) {
    /* faq */
  }
  else if (msg.includes('li√™n h·ªá') || msg.includes('h·ªó tr·ª£')) {
    reply = contactInfo();
  }
  else {
    try {
      reply = await aiGenerateReply(msg);
    } catch (e) {
      console.error('‚ùå OpenRouter error:', e.response?.data || e);
      reply = 'Xin l·ªói, ƒë√£ x·∫£y ra l·ªói khi k·∫øt n·ªëi AI.';
    }
  }

  logChat(msg, reply);
  return res.json({ reply });
});

// ======= Start server =======
const PORT = process.env.PORT || 3000;
app.listen(PORT, () => {
  console.log(`üöÄ Server ƒëang ch·∫°y tr√™n http://localhost:${PORT}`);
});
